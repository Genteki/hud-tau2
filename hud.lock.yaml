version: '1.3'
images:
  local: tau2:0.1.24
  full: tau2:0.1.24@sha256:46e9ec4f680b66f056dc9a2608fe48241029c76854a8691bb3654d38ac7c22eb
  pushed: null
build:
  generatedAt: 2025-12-22T19:53:40.876977+00:00Z
  hudVersion: 0.5.0
  directory: hud-tau2
  version: 0.1.24
  sourceHash: c179ed8147ba97cdee39a70aadd8c8b558e345f43635d7d6b3cfb0d11172bb22
  baseImage: python:3.12-slim
  platform: linux/amd64
  sourceFiles:
  - Dockerfile
  - environment/__init__.py
  - environment/run_server.py
  - environment/server.py
  - environment/toolkit.py
  - pyproject.toml
  - server/__init__.py
  - server/evaluate/__init__.py
  - server/evaluate/eval.py
  - server/main.py
  - server/scenarios.py
  - server/setup/__init__.py
  - server/setup/load.py
  - server/state.py
  - server/tools/__init__.py
  - server/tools/_wrapper.py
  - server/tools/conversation.py
  - server/tools/conversation_new.py
  - server/tools/http_client.py
  - server/tools/http_tool.py
  - server/tools/test_http_tool.py
environment:
  initializeMs: 4862
  toolCount: 18
  runtime:
    python: 3.12.12
    cuda: null
    cudnn: null
    pytorch: null
  internalToolCount: 2
tools:
- name: _hud_submit
  description: "Submit the agent's answer for a scenario's evaluate phase.\n\nInternal\
    \ tool - called by Environment.submit() on connected hubs.\n\nArgs:\n    scenario:\
    \ Name of the scenario (without env prefix)\n    answer: The agent's answer/result\
    \ to submit"
  inputSchema:
    properties:
      scenario:
        type: string
      answer:
        type: string
    required:
    - scenario
    - answer
    type: object
- name: send_message
  description: Send a message to the customer and receive their response. Use this
    to communicate with the customer during the conversation. The customer will respond
    naturally based on their needs. When the customer is satisfied, they will indicate
    the conversation should end.
  inputSchema:
    properties:
      message:
        type: string
    required:
    - message
    type: object
- name: book_reservation
  description: "def book_reservation(user_id: str, origin: str, destination: str,\
    \ flight_type: Literal['round_trip', 'one_way'], cabin: Literal['business', 'economy',\
    \ 'basic_economy'], flights: List[tau2.domains.airline.data_model.FlightInfo |\
    \ dict], passengers: List[tau2.domains.airline.data_model.Passenger | dict], payment_methods:\
    \ List[tau2.domains.airline.data_model.Payment | dict], total_baggages: int, nonfree_baggages:\
    \ int, insurance: Literal['yes', 'no']) -> tau2.domains.airline.data_model.Reservation:\n\
    \    \"\"\"\n        Book a reservation.\n\n        Args:\n            user_id:\
    \ The ID of the user to book the reservation such as 'sara_doe_496'`.\n      \
    \      origin: The IATA code for the origin city such as 'SFO'.\n            destination:\
    \ The IATA code for the destination city such as 'JFK'.\n            flight_type:\
    \ The type of flight such as 'one_way' or 'round_trip'.\n            cabin: The\
    \ cabin class such as 'basic_economy', 'economy', or 'business'.\n           \
    \ flights: An array of objects containing details about each piece of flight.\n\
    \            passengers: An array of objects containing details about each passenger.\n\
    \            payment_methods: An array of objects containing details about each\
    \ payment method.\n            total_baggages: The total number of baggage items\
    \ to book the reservation.\n            nonfree_baggages: The number of non-free\
    \ baggage items to book the reservation.\n            insurance: Whether the reservation\
    \ has insurance.\n        \"\"\""
  inputSchema:
    $defs:
      FlightInfo:
        properties:
          flight_number:
            description: Flight number, such as 'HAT001'.
            title: Flight Number
            type: string
          date:
            description: The date for the flight in the format 'YYYY-MM-DD', such
              as '2024-05-01'.
            title: Date
            type: string
        required:
        - flight_number
        - date
        title: FlightInfo
        type: object
      Passenger:
        properties:
          first_name:
            description: Passenger's first name
            title: First Name
            type: string
          last_name:
            description: Passenger's last name
            title: Last Name
            type: string
          dob:
            description: Date of birth in YYYY-MM-DD format
            title: Dob
            type: string
        required:
        - first_name
        - last_name
        - dob
        title: Passenger
        type: object
      Payment:
        properties:
          payment_id:
            description: Unique identifier for the payment
            title: Payment Id
            type: string
          amount:
            description: Payment amount in dollars
            title: Amount
            type: integer
        required:
        - payment_id
        - amount
        title: Payment
        type: object
    properties:
      user_id:
        description: The ID of the user to book the reservation such as 'sara_doe_496'`.
        title: User Id
        type: string
      origin:
        description: The IATA code for the origin city such as 'SFO'.
        title: Origin
        type: string
      destination:
        description: The IATA code for the destination city such as 'JFK'.
        title: Destination
        type: string
      flight_type:
        description: The type of flight such as 'one_way' or 'round_trip'.
        enum:
        - round_trip
        - one_way
        title: Flight Type
        type: string
      cabin:
        description: The cabin class such as 'basic_economy', 'economy', or 'business'.
        enum:
        - business
        - economy
        - basic_economy
        title: Cabin
        type: string
      flights:
        description: An array of objects containing details about each piece of flight.
        items:
          anyOf:
          - $ref: '#/$defs/FlightInfo'
          - additionalProperties: true
            type: object
        title: Flights
        type: array
      passengers:
        description: An array of objects containing details about each passenger.
        items:
          anyOf:
          - $ref: '#/$defs/Passenger'
          - additionalProperties: true
            type: object
        title: Passengers
        type: array
      payment_methods:
        description: An array of objects containing details about each payment method.
        items:
          anyOf:
          - $ref: '#/$defs/Payment'
          - additionalProperties: true
            type: object
        title: Payment Methods
        type: array
      total_baggages:
        description: The total number of baggage items to book the reservation.
        title: Total Baggages
        type: integer
      nonfree_baggages:
        description: The number of non-free baggage items to book the reservation.
        title: Nonfree Baggages
        type: integer
      insurance:
        description: Whether the reservation has insurance.
        enum:
        - 'yes'
        - 'no'
        title: Insurance
        type: string
    required:
    - user_id
    - origin
    - destination
    - flight_type
    - cabin
    - flights
    - passengers
    - payment_methods
    - total_baggages
    - nonfree_baggages
    - insurance
    title: parameters
    type: object
- name: calculate
  description: "def calculate(expression: str) -> str:\n    \"\"\"\n        Calculate\
    \ the result of a mathematical expression.\n\n        Args:\n            expression:\
    \ The mathematical expression to calculate, such as '2 + 2'. The expression can\
    \ contain numbers, operators (+, -, *, /), parentheses, and spaces.\n\n      \
    \  Returns:\n            The result of the mathematical expression.\n\n      \
    \  Raises:\n            ValueError: If the expression is invalid.\n        \"\"\
    \""
  inputSchema:
    properties:
      expression:
        description: The mathematical expression to calculate, such as '2 + 2'. The
          expression can contain numbers, operators (+, -, *, /), parentheses, and
          spaces.
        title: Expression
        type: string
    required:
    - expression
    title: parameters
    type: object
- name: cancel_reservation
  description: "def cancel_reservation(reservation_id: str) -> tau2.domains.airline.data_model.Reservation:\n\
    \    \"\"\"\n        Cancel the whole reservation.\n\n        Args:\n        \
    \    reservation_id: The reservation ID, such as 'ZFA04Y'.\n\n        Returns:\n\
    \            The updated reservation.\n\n        Raises:\n            ValueError:\
    \ If the reservation is not found.\n        \"\"\""
  inputSchema:
    properties:
      reservation_id:
        description: The reservation ID, such as 'ZFA04Y'.
        title: Reservation Id
        type: string
    required:
    - reservation_id
    title: parameters
    type: object
- name: get_reservation_details
  description: "def get_reservation_details(reservation_id: str) -> tau2.domains.airline.data_model.Reservation:\n\
    \    \"\"\"\n        Get the details of a reservation.\n\n        Args:\n    \
    \        reservation_id: The reservation ID, such as '8JX2WO'.\n\n        Returns:\n\
    \            The reservation details.\n\n        Raises:\n            ValueError:\
    \ If the reservation is not found.\n        \"\"\""
  inputSchema:
    properties:
      reservation_id:
        description: The reservation ID, such as '8JX2WO'.
        title: Reservation Id
        type: string
    required:
    - reservation_id
    title: parameters
    type: object
- name: get_user_details
  description: "def get_user_details(user_id: str) -> tau2.domains.airline.data_model.User:\n\
    \    \"\"\"\n        Get the details of a user, including their reservations.\n\
    \n        Args:\n            user_id: The user ID, such as 'sara_doe_496'.\n\n\
    \        Returns:\n            The user details.\n\n        Raises:\n        \
    \    ValueError: If the user is not found.\n        \"\"\""
  inputSchema:
    properties:
      user_id:
        description: The user ID, such as 'sara_doe_496'.
        title: User Id
        type: string
    required:
    - user_id
    title: parameters
    type: object
- name: list_all_airports
  description: "def list_all_airports() -> Annotated[list[tau2.domains.airline.data_model.AirportCode],\
    \ FieldInfo(annotation=NoneType, required=True, description='Airport information')]:\n\
    \    \"\"\"Returns a list of all available airports.\n\n        Returns:\n   \
    \         A dictionary mapping IATA codes to AirportInfo objects.\n        \"\"\
    \""
  inputSchema:
    properties: {}
    title: parameters
    type: object
- name: search_direct_flight
  description: "def search_direct_flight(origin: str, destination: str, date: str)\
    \ -> list[tau2.domains.airline.data_model.DirectFlight]:\n    \"\"\"\n       \
    \ Search for direct flights between two cities on a specific date.\n\n       \
    \ Args:\n            origin: The origin city airport in three letters, such as\
    \ 'JFK'.\n            destination: The destination city airport in three letters,\
    \ such as 'LAX'.\n            date: The date of the flight in the format 'YYYY-MM-DD',\
    \ such as '2024-01-01'.\n\n        Returns:\n            The direct flights between\
    \ the two cities on the specific date.\n        \"\"\""
  inputSchema:
    properties:
      origin:
        description: The origin city airport in three letters, such as 'JFK'.
        title: Origin
        type: string
      destination:
        description: The destination city airport in three letters, such as 'LAX'.
        title: Destination
        type: string
      date:
        description: The date of the flight in the format 'YYYY-MM-DD', such as '2024-01-01'.
        title: Date
        type: string
    required:
    - origin
    - destination
    - date
    title: parameters
    type: object
- name: search_onestop_flight
  description: "def search_onestop_flight(origin: str, destination: str, date: str)\
    \ -> list[tuple[tau2.domains.airline.data_model.DirectFlight, tau2.domains.airline.data_model.DirectFlight]]:\n\
    \    \"\"\"\n        Search for one-stop flights between two cities on a specific\
    \ date.\n\n        Args:\n            origin: The origin city airport in three\
    \ letters, such as 'JFK'.\n            destination: The destination city airport\
    \ in three letters, such as 'LAX'.\n            date: The date of the flight in\
    \ the format 'YYYY-MM-DD', such as '2024-05-01'.\n\n        Returns:\n       \
    \     A list of pairs of DirectFlight objects.\n        \"\"\""
  inputSchema:
    properties:
      origin:
        description: The origin city airport in three letters, such as 'JFK'.
        title: Origin
        type: string
      destination:
        description: The destination city airport in three letters, such as 'LAX'.
        title: Destination
        type: string
      date:
        description: The date of the flight in the format 'YYYY-MM-DD', such as '2024-05-01'.
        title: Date
        type: string
    required:
    - origin
    - destination
    - date
    title: parameters
    type: object
- name: send_certificate
  description: "def send_certificate(user_id: str, amount: int) -> str:\n    \"\"\"\
    \n        Send a certificate to a user. Be careful!\n\n        Args:\n       \
    \     user_id: The ID of the user to book the reservation, such as 'sara_doe_496'.\n\
    \            amount: The amount of the certificate to send.\n\n        Returns:\n\
    \            A message indicating the certificate was sent.\n\n        Raises:\n\
    \            ValueError: If the user is not found.\n        \"\"\""
  inputSchema:
    properties:
      user_id:
        description: The ID of the user to book the reservation, such as 'sara_doe_496'.
        title: User Id
        type: string
      amount:
        description: The amount of the certificate to send.
        title: Amount
        type: integer
    required:
    - user_id
    - amount
    title: parameters
    type: object
- name: transfer_to_human_agents
  description: "def transfer_to_human_agents(summary: str) -> str:\n    \"\"\"\n \
    \       Transfer the user to a human agent, with a summary of the user's issue.\n\
    \        Only transfer if\n         -  the user explicitly asks for a human agent\n\
    \         -  given the policy and the available tools, you cannot solve the user's\
    \ issue.\n\n        Args:\n            summary: A summary of the user's issue.\n\
    \n        Returns:\n            A message indicating the user has been transferred\
    \ to a human agent.\n        \"\"\""
  inputSchema:
    properties:
      summary:
        description: A summary of the user's issue.
        title: Summary
        type: string
    required:
    - summary
    title: parameters
    type: object
- name: update_reservation_baggages
  description: "def update_reservation_baggages(reservation_id: str, total_baggages:\
    \ int, nonfree_baggages: int, payment_id: str) -> tau2.domains.airline.data_model.Reservation:\n\
    \    \"\"\"\n        Update the baggage information of a reservation.\n\n    \
    \    Args:\n            reservation_id: The reservation ID, such as 'ZFA04Y'\n\
    \            total_baggages: The updated total number of baggage items included\
    \ in the reservation.\n            nonfree_baggages: The updated number of non-free\
    \ baggage items included in the reservation.\n            payment_id: The payment\
    \ id stored in user profile, such as 'credit_card_7815826', 'gift_card_7815826',\
    \ 'certificate_7815826'.\n\n        Returns:\n            The updated reservation.\n\
    \n        Raises:\n            ValueError: If the reservation is not found.\n\
    \            ValueError: If the user is not found.\n            ValueError: If\
    \ the payment method is not found.\n            ValueError: If the certificate\
    \ cannot be used to update reservation.\n            ValueError: If the gift card\
    \ balance is not enough.\n        \"\"\""
  inputSchema:
    properties:
      reservation_id:
        description: The reservation ID, such as 'ZFA04Y'
        title: Reservation Id
        type: string
      total_baggages:
        description: The updated total number of baggage items included in the reservation.
        title: Total Baggages
        type: integer
      nonfree_baggages:
        description: The updated number of non-free baggage items included in the
          reservation.
        title: Nonfree Baggages
        type: integer
      payment_id:
        description: The payment id stored in user profile, such as 'credit_card_7815826',
          'gift_card_7815826', 'certificate_7815826'.
        title: Payment Id
        type: string
    required:
    - reservation_id
    - total_baggages
    - nonfree_baggages
    - payment_id
    title: parameters
    type: object
- name: update_reservation_flights
  description: "def update_reservation_flights(reservation_id: str, cabin: Literal['business',\
    \ 'economy', 'basic_economy'], flights: List[tau2.domains.airline.data_model.FlightInfo\
    \ | dict], payment_id: str) -> tau2.domains.airline.data_model.Reservation:\n\
    \    \"\"\"\n        Update the flight information of a reservation.\n\n\n   \
    \     Args:\n            reservation_id: The reservation ID, such as 'ZFA04Y'.\n\
    \            cabin: The cabin class of the reservation\n            flights: An\
    \ array of objects containing details about each piece of flight in the ENTIRE\
    \ new reservation. Even if the a flight segment is not changed, it should still\
    \ be included in the array.\n            payment_id: The payment id stored in\
    \ user profile, such as 'credit_card_7815826', 'gift_card_7815826', 'certificate_7815826'.\n\
    \n        Returns:\n            The updated reservation.\n\n        Raises:\n\
    \            ValueError: If the reservation is not found.\n            ValueError:\
    \ If the user is not found.\n            ValueError: If the payment method is\
    \ not found.\n            ValueError: If the certificate cannot be used to update\
    \ reservation.\n            ValueError: If the gift card balance is not enough.\n\
    \        \"\"\""
  inputSchema:
    $defs:
      FlightInfo:
        properties:
          flight_number:
            description: Flight number, such as 'HAT001'.
            title: Flight Number
            type: string
          date:
            description: The date for the flight in the format 'YYYY-MM-DD', such
              as '2024-05-01'.
            title: Date
            type: string
        required:
        - flight_number
        - date
        title: FlightInfo
        type: object
    properties:
      reservation_id:
        description: The reservation ID, such as 'ZFA04Y'.
        title: Reservation Id
        type: string
      cabin:
        description: The cabin class of the reservation
        enum:
        - business
        - economy
        - basic_economy
        title: Cabin
        type: string
      flights:
        description: An array of objects containing details about each piece of flight
          in the ENTIRE new reservation. Even if the a flight segment is not changed,
          it should still be included in the array.
        items:
          anyOf:
          - $ref: '#/$defs/FlightInfo'
          - additionalProperties: true
            type: object
        title: Flights
        type: array
      payment_id:
        description: The payment id stored in user profile, such as 'credit_card_7815826',
          'gift_card_7815826', 'certificate_7815826'.
        title: Payment Id
        type: string
    required:
    - reservation_id
    - cabin
    - flights
    - payment_id
    title: parameters
    type: object
- name: update_reservation_passengers
  description: "def update_reservation_passengers(reservation_id: str, passengers:\
    \ List[tau2.domains.airline.data_model.Passenger | dict]) -> tau2.domains.airline.data_model.Reservation:\n\
    \    \"\"\"\n        Update the passenger information of a reservation.\n\n  \
    \      Args:\n            reservation_id: The reservation ID, such as 'ZFA04Y'.\n\
    \            passengers: An array of objects containing details about each passenger.\n\
    \n        Returns:\n            The updated reservation.\n\n        Raises:\n\
    \            ValueError: If the reservation is not found.\n            ValueError:\
    \ If the number of passengers does not match.\n        \"\"\""
  inputSchema:
    $defs:
      Passenger:
        properties:
          first_name:
            description: Passenger's first name
            title: First Name
            type: string
          last_name:
            description: Passenger's last name
            title: Last Name
            type: string
          dob:
            description: Date of birth in YYYY-MM-DD format
            title: Dob
            type: string
        required:
        - first_name
        - last_name
        - dob
        title: Passenger
        type: object
    properties:
      reservation_id:
        description: The reservation ID, such as 'ZFA04Y'.
        title: Reservation Id
        type: string
      passengers:
        description: An array of objects containing details about each passenger.
        items:
          anyOf:
          - $ref: '#/$defs/Passenger'
          - additionalProperties: true
            type: object
        title: Passengers
        type: array
    required:
    - reservation_id
    - passengers
    title: parameters
    type: object
- name: get_flight_status
  description: "def get_flight_status(flight_number: str, date: str) -> str:\n   \
    \ \"\"\"\n        Get the status of a flight.\n\n        Args:\n            flight_number:\
    \ The flight number.\n            date: The date of the flight.\n\n        Returns:\n\
    \            The status of the flight.\n\n        Raises:\n            ValueError:\
    \ If the flight is not found.\n        \"\"\""
  inputSchema:
    properties:
      flight_number:
        description: The flight number.
        title: Flight Number
        type: string
      date:
        description: The date of the flight.
        title: Date
        type: string
    required:
    - flight_number
    - date
    title: parameters
    type: object
- name: setup
  description: "Call internal 'setup' functions. Available tools:\n\n\u2022 Name:\
    \ load (Complete setup: load domain, set task, and initialize environment.\n\n\
    Args:\n    domain: The domain to use (airline, retail, telecom, or mock)\n   \
    \ task_id: The task ID to load\n    task_split: Optional task split name (e.g.,\
    \ \"base\", \"train\", \"test\")\n    solo_mode: Whether to run in solo mode (default:\
    \ False)\n    start_conversation: If True and solo_mode=False, send initial greeting\
    \ (default: False)\n    initial_greeting: The greeting to send if start_conversation=True\n\
    \nReturns:\n    Setup status with task and environment information, plus user's\
    \ first response if start_conversation=True)\n  Arguments: domain (string), task_id\
    \ (string), task_split (string | null) (optional), solo_mode (boolean) (optional),\
    \ start_conversation (boolean) (optional), initial_greeting (string) (optional)"
  inputSchema:
    type: object
    properties:
      name:
        type: string
        description: 'Name of the internal tool to call. Must be one of: load'
        enum:
        - load
      arguments:
        anyOf:
        - type: object
          description: Arguments object to pass to the internal tool
        - type: string
          description: JSON string of arguments to pass to the internal tool
        description: Arguments to pass to the internal tool. Can be an object or JSON
          string. See description for details on each tool's parameters.
    required:
    - name
    - arguments
    examples:
    - name: load
      arguments:
        domain: <domain>
        task_id: <task_id>
        task_split: null
        solo_mode: true
        start_conversation: true
        initial_greeting: <initial_greeting>
  internalTools:
  - load
- name: evaluate
  description: "Call internal 'evaluate' functions. Available tools:\n\n\u2022 Name:\
    \ evaluate_task (Evaluate the current task based on the conversation history.\n\
    \nArgs:\n    evaluation_type: Type of evaluation to run\n        - \"env\": Environment\
    \ state evaluation\n        - \"action\": Action completion evaluation\n     \
    \   - \"communicate\": Communication evaluation\n        - \"nl_assertions\":\
    \ Natural language assertions\n        - \"all\": All evaluation types combined\
    \ (default)\n\nReturns:\n    EvaluationResult with reward, done status, and feedback)\n\
    \  Arguments: evaluation_type (string) (optional)"
  inputSchema:
    type: object
    properties:
      name:
        type: string
        description: 'Name of the internal tool to call. Must be one of: evaluate_task'
        enum:
        - evaluate_task
      arguments:
        anyOf:
        - type: object
          description: Arguments object to pass to the internal tool
        - type: string
          description: JSON string of arguments to pass to the internal tool
        description: Arguments to pass to the internal tool. Can be an object or JSON
          string. See description for details on each tool's parameters.
    required:
    - name
    - arguments
    examples:
    - name: evaluate_task
      arguments:
        evaluation_type: <evaluation_type>
  internalTools:
  - evaluate_task
hubTools:
  setup:
  - load
  evaluate:
  - evaluate_task
prompts:
- name: tau2-bench:tau2
  description: "[Setup] \n        Run a TAU2-bench customer service task.\n\n    \
    \    Args:\n            domain: Domain to test (airline, retail, telecom)\n  \
    \          task_id: Task ID within the domain (int for airline/retail, str for\
    \ telecom)\n            task_split: Task split (base, dev, test)\n\n        Returns:\n\
    \            Task evaluation result\n        "
  arguments:
  - name: domain
    required: false
    description: null
    default: airline
    type: string
  - name: task_id
    required: false
    description: null
    default: 0
    inputSchema: &id001
      anyOf:
      - type: integer
      - type: string
  - name: task_split
    required: false
    description: null
    default: base
    type: string
  meta:
    code: "    @env.scenario(\"tau2\")\n    async def tau2_scenario(\n        domain:\
      \ str = \"airline\",\n        task_id: int | str = 0,\n        task_split: str\
      \ = \"base\"\n    ) -> Any:\n        \"\"\"\n        Run a TAU2-bench customer\
      \ service task.\n\n        Args:\n            domain: Domain to test (airline,\
      \ retail, telecom)\n            task_id: Task ID within the domain (int for\
      \ airline/retail, str for telecom)\n            task_split: Task split (base,\
      \ dev, test)\n\n        Returns:\n            Task evaluation result\n     \
      \   \"\"\"\n        # ===== SETUP SECTION =====\n        # Load the task and\
      \ initialize environment directly (not via tool call)\n        logger.info(f\"\
      Setting up tau2 scenario: domain={domain}, task_id={task_id}, split={task_split}\"\
      )\n\n        from server.tools.http_client import get_http_client\n        from\
      \ server.state import get_tau2_task\n        from tau2.registry import registry\n\
      \n        try:\n            # Initialize scenario via HTTP\n            http_client\
      \ = get_http_client()\n            result = http_client.initialize_scenario(\n\
      \                domain=domain,\n                task_id=str(task_id),\n   \
      \             task_split=task_split\n            )\n\n            if \"error\"\
      \ in result:\n                logger.error(f\"Setup failed: {result['error']}\"\
      )\n                yield f\"Setup failed: {result['error']}\"\n            \
      \    yield 0.0\n                return\n\n            initial_greeting = result.get(\"\
      initial_greeting\", \"Hi! How can I help you today?\")\n\n            # Also\
      \ update global tau2_task state (for message tracking and evaluation)\n    \
      \        tau2_task = get_tau2_task()\n            task_loader = registry.get_tasks_loader(domain)\n\
      \            tasks = task_loader(task_split_name=task_split)\n            tau2_task.domain\
      \ = domain\n            tau2_task.tasks = tasks\n            tau2_task.set_task(str(task_id))\n\
      \            tau2_task.solo_mode = False\n\n            logger.info(f\"Scenario\
      \ initialized: domain={domain}, task_id={task_id}, split={task_split}\")\n\n\
      \            # Dynamically load tools for this domain from environment server\n\
      \            from server.tools.http_tool import create_http_tools_from_server,\
      \ get_http_tool_registry\n            from env import env as hud_env\n\n   \
      \         # Clear old domain tools from registry\n            tool_registry\
      \ = get_http_tool_registry()\n            tool_registry.clear()\n\n        \
      \    # Load new tools for current domain\n            http_tools = create_http_tools_from_server()\n\
      \n            # Add tools to environment (this registers them with the MCP server)\n\
      \            for tool_name, http_tool in http_tools.items():\n             \
      \   hud_env.add_tool(http_tool)\n\n            logger.info(f\"Loaded {len(http_tools)}\
      \ tools for domain '{domain}'\")\n\n        except Exception as e:\n       \
      \     logger.error(f\"Setup failed: {e}\")\n            import traceback\n \
      \           traceback.print_exc()\n            yield f\"Setup failed: {e}\"\n\
      \            yield 0.0\n            return\n\n        # ===== PROMPT (first\
      \ yield) =====\n        # Provide the task prompt to the agent with policy (like\
      \ original tau2-bench)\n        # Get policy from environment server\n     \
      \   try:\n            policy = http_client.get_policy()\n        except Exception\
      \ as e:\n            logger.warning(f\"Could not get policy: {e}\")\n      \
      \      policy = \"No specific policy available.\"\n\n        prompt = f\"\"\"\
      You are a customer service agent for {domain}.\n\n<instructions>\nYou are a\
      \ customer service agent that helps the user according to the <policy> provided\
      \ below.\nIn each turn you can either:\n- Send a message to the user using the\
      \ send_message tool.\n- Make a tool call to check or modify data.\nYou cannot\
      \ do both at the same time.\n\nTry to be helpful and always follow the policy.\n\
      </instructions>\n\n<policy>\n{policy}\n</policy>\n\nThe customer has sent you\
      \ this message:\n{initial_greeting}\n\nUse the send_message tool to respond\
      \ to the customer.\n\"\"\"\n\n        # Yield the prompt and let the agent interact\n\
      \        # The answer is not used since tau2 evaluates the full conversation\
      \ trajectory\n        _ = yield prompt\n\n        # ===== EVALUATE SECTION =====\n\
      \        # Evaluate the conversation using TAU2-bench's evaluation (directly,\
      \ not via tool call)\n        logger.info(\"Evaluating tau2 task completion\"\
      )\n\n        try:\n            tau2_task = get_tau2_task()\n\n            #\
      \ Run tau2-bench evaluation (inline, same as evaluate/eval.py)\n           \
      \ from tau2.evaluator.evaluator import evaluate_simulation, EvaluationType\n\
      \            from tau2.data_model.simulation import SimulationRun, TerminationReason\n\
      \            from tau2.utils.utils import get_now\n            import uuid\n\
      \n            # Validate task state\n            assert tau2_task.task is not\
      \ None, \"Task not loaded\"\n            assert tau2_task.domain is not None,\
      \ \"Domain not set\"\n\n            # Create SimulationRun from current state\n\
      \            current_time = get_now()\n            simulation = SimulationRun(\n\
      \                id=str(uuid.uuid4()),\n                task_id=tau2_task.task.id,\n\
      \                start_time=current_time,\n                end_time=current_time,\n\
      \                duration=0.0,\n                messages=tau2_task.messages,\n\
      \                termination_reason=TerminationReason.AGENT_STOP,\n        \
      \    )\n\n            # Run evaluation\n            reward_info = evaluate_simulation(\n\
      \                simulation=simulation,\n                task=tau2_task.task,\n\
      \                evaluation_type=EvaluationType.ALL,\n                solo_mode=tau2_task.solo_mode,\n\
      \                domain=tau2_task.domain,\n            )\n\n            reward\
      \ = float(reward_info.reward)\n\n            # Log detailed evaluation summary\n\
      \            logger.info(\"=\" * 60)\n            logger.info(\"EVALUATION SUMMARY\"\
      )\n            logger.info(\"=\" * 60)\n            logger.info(f\"Final Reward:\
      \ {reward}\")\n\n            if reward_info.reward_breakdown:\n            \
      \    logger.info(\"\\nReward Breakdown:\")\n                for reward_type,\
      \ value in reward_info.reward_breakdown.items():\n                    logger.info(f\"\
      \  {reward_type}: {value}\")\n\n            if reward_info.db_check:\n     \
      \           logger.info(f\"\\nDatabase Check: match={reward_info.db_check.db_match},\
      \ reward={reward_info.db_check.db_reward}\")\n\n            if reward_info.env_assertions:\n\
      \                logger.info(f\"\\nEnvironment Assertions: {len(reward_info.env_assertions)}\
      \ checks\")\n                for i, check in enumerate(reward_info.env_assertions):\n\
      \                    logger.info(f\"  [{i+1}] {check.env_assertion}: met={check.met},\
      \ reward={check.reward}\")\n\n            if reward_info.action_checks:\n  \
      \              logger.info(f\"\\nAction Checks: {len(reward_info.action_checks)}\
      \ checks\")\n                for i, check in enumerate(reward_info.action_checks):\n\
      \                    logger.info(f\"  [{i+1}] {check.action}: match={check.action_match},\
      \ reward={check.action_reward}\")\n\n            if reward_info.nl_assertions:\n\
      \                logger.info(f\"\\nNL Assertions: {len(reward_info.nl_assertions)}\
      \ checks\")\n                for i, check in enumerate(reward_info.nl_assertions):\n\
      \                    logger.info(f\"  [{i+1}] {check.nl_assertion}: met={check.met}\"\
      )\n                    if check.justification:\n                        logger.info(f\"\
      \      Justification: {check.justification}\")\n\n            if reward_info.communicate_checks:\n\
      \                logger.info(f\"\\nCommunication Checks: {len(reward_info.communicate_checks)}\
      \ checks\")\n                for i, check in enumerate(reward_info.communicate_checks):\n\
      \                    logger.info(f\"  [{i+1}] {check.info}: met={check.met}\"\
      )\n                    if check.justification:\n                        logger.info(f\"\
      \      Justification: {check.justification}\")\n\n            if reward_info.info:\n\
      \                logger.info(f\"\\nAdditional Info: {reward_info.info}\")\n\n\
      \            logger.info(\"=\" * 60)\n\n        except Exception as e:\n   \
      \         logger.error(f\"Evaluation failed: {e}\")\n            import traceback\n\
      \            traceback.print_exc()\n            reward = 0.0\n\n        # =====\
      \ REWARD (second yield) =====\n        yield reward\n"
    arguments:
    - name: domain
      required: false
      default: airline
      type: string
    - name: task_id
      required: false
      default: 0
      inputSchema: *id001
    - name: task_split
      required: false
      default: base
      type: string
    _fastmcp:
      tags: []
resources:
- uri: tau2-bench:tau2
  name: tau2
  description: "[Evaluate] \n        Run a TAU2-bench customer service task.\n\n \
    \       Args:\n            domain: Domain to test (airline, retail, telecom)\n\
    \            task_id: Task ID within the domain (int for airline/retail, str for\
    \ telecom)\n            task_split: Task split (base, dev, test)\n\n        Returns:\n\
    \            Task evaluation result\n        "
  mime_type: application/json
  meta:
    code: "    @env.scenario(\"tau2\")\n    async def tau2_scenario(\n        domain:\
      \ str = \"airline\",\n        task_id: int | str = 0,\n        task_split: str\
      \ = \"base\"\n    ) -> Any:\n        \"\"\"\n        Run a TAU2-bench customer\
      \ service task.\n\n        Args:\n            domain: Domain to test (airline,\
      \ retail, telecom)\n            task_id: Task ID within the domain (int for\
      \ airline/retail, str for telecom)\n            task_split: Task split (base,\
      \ dev, test)\n\n        Returns:\n            Task evaluation result\n     \
      \   \"\"\"\n        # ===== SETUP SECTION =====\n        # Load the task and\
      \ initialize environment directly (not via tool call)\n        logger.info(f\"\
      Setting up tau2 scenario: domain={domain}, task_id={task_id}, split={task_split}\"\
      )\n\n        from server.tools.http_client import get_http_client\n        from\
      \ server.state import get_tau2_task\n        from tau2.registry import registry\n\
      \n        try:\n            # Initialize scenario via HTTP\n            http_client\
      \ = get_http_client()\n            result = http_client.initialize_scenario(\n\
      \                domain=domain,\n                task_id=str(task_id),\n   \
      \             task_split=task_split\n            )\n\n            if \"error\"\
      \ in result:\n                logger.error(f\"Setup failed: {result['error']}\"\
      )\n                yield f\"Setup failed: {result['error']}\"\n            \
      \    yield 0.0\n                return\n\n            initial_greeting = result.get(\"\
      initial_greeting\", \"Hi! How can I help you today?\")\n\n            # Also\
      \ update global tau2_task state (for message tracking and evaluation)\n    \
      \        tau2_task = get_tau2_task()\n            task_loader = registry.get_tasks_loader(domain)\n\
      \            tasks = task_loader(task_split_name=task_split)\n            tau2_task.domain\
      \ = domain\n            tau2_task.tasks = tasks\n            tau2_task.set_task(str(task_id))\n\
      \            tau2_task.solo_mode = False\n\n            logger.info(f\"Scenario\
      \ initialized: domain={domain}, task_id={task_id}, split={task_split}\")\n\n\
      \            # Dynamically load tools for this domain from environment server\n\
      \            from server.tools.http_tool import create_http_tools_from_server,\
      \ get_http_tool_registry\n            from env import env as hud_env\n\n   \
      \         # Clear old domain tools from registry\n            tool_registry\
      \ = get_http_tool_registry()\n            tool_registry.clear()\n\n        \
      \    # Load new tools for current domain\n            http_tools = create_http_tools_from_server()\n\
      \n            # Add tools to environment (this registers them with the MCP server)\n\
      \            for tool_name, http_tool in http_tools.items():\n             \
      \   hud_env.add_tool(http_tool)\n\n            logger.info(f\"Loaded {len(http_tools)}\
      \ tools for domain '{domain}'\")\n\n        except Exception as e:\n       \
      \     logger.error(f\"Setup failed: {e}\")\n            import traceback\n \
      \           traceback.print_exc()\n            yield f\"Setup failed: {e}\"\n\
      \            yield 0.0\n            return\n\n        # ===== PROMPT (first\
      \ yield) =====\n        # Provide the task prompt to the agent with policy (like\
      \ original tau2-bench)\n        # Get policy from environment server\n     \
      \   try:\n            policy = http_client.get_policy()\n        except Exception\
      \ as e:\n            logger.warning(f\"Could not get policy: {e}\")\n      \
      \      policy = \"No specific policy available.\"\n\n        prompt = f\"\"\"\
      You are a customer service agent for {domain}.\n\n<instructions>\nYou are a\
      \ customer service agent that helps the user according to the <policy> provided\
      \ below.\nIn each turn you can either:\n- Send a message to the user using the\
      \ send_message tool.\n- Make a tool call to check or modify data.\nYou cannot\
      \ do both at the same time.\n\nTry to be helpful and always follow the policy.\n\
      </instructions>\n\n<policy>\n{policy}\n</policy>\n\nThe customer has sent you\
      \ this message:\n{initial_greeting}\n\nUse the send_message tool to respond\
      \ to the customer.\n\"\"\"\n\n        # Yield the prompt and let the agent interact\n\
      \        # The answer is not used since tau2 evaluates the full conversation\
      \ trajectory\n        _ = yield prompt\n\n        # ===== EVALUATE SECTION =====\n\
      \        # Evaluate the conversation using TAU2-bench's evaluation (directly,\
      \ not via tool call)\n        logger.info(\"Evaluating tau2 task completion\"\
      )\n\n        try:\n            tau2_task = get_tau2_task()\n\n            #\
      \ Run tau2-bench evaluation (inline, same as evaluate/eval.py)\n           \
      \ from tau2.evaluator.evaluator import evaluate_simulation, EvaluationType\n\
      \            from tau2.data_model.simulation import SimulationRun, TerminationReason\n\
      \            from tau2.utils.utils import get_now\n            import uuid\n\
      \n            # Validate task state\n            assert tau2_task.task is not\
      \ None, \"Task not loaded\"\n            assert tau2_task.domain is not None,\
      \ \"Domain not set\"\n\n            # Create SimulationRun from current state\n\
      \            current_time = get_now()\n            simulation = SimulationRun(\n\
      \                id=str(uuid.uuid4()),\n                task_id=tau2_task.task.id,\n\
      \                start_time=current_time,\n                end_time=current_time,\n\
      \                duration=0.0,\n                messages=tau2_task.messages,\n\
      \                termination_reason=TerminationReason.AGENT_STOP,\n        \
      \    )\n\n            # Run evaluation\n            reward_info = evaluate_simulation(\n\
      \                simulation=simulation,\n                task=tau2_task.task,\n\
      \                evaluation_type=EvaluationType.ALL,\n                solo_mode=tau2_task.solo_mode,\n\
      \                domain=tau2_task.domain,\n            )\n\n            reward\
      \ = float(reward_info.reward)\n\n            # Log detailed evaluation summary\n\
      \            logger.info(\"=\" * 60)\n            logger.info(\"EVALUATION SUMMARY\"\
      )\n            logger.info(\"=\" * 60)\n            logger.info(f\"Final Reward:\
      \ {reward}\")\n\n            if reward_info.reward_breakdown:\n            \
      \    logger.info(\"\\nReward Breakdown:\")\n                for reward_type,\
      \ value in reward_info.reward_breakdown.items():\n                    logger.info(f\"\
      \  {reward_type}: {value}\")\n\n            if reward_info.db_check:\n     \
      \           logger.info(f\"\\nDatabase Check: match={reward_info.db_check.db_match},\
      \ reward={reward_info.db_check.db_reward}\")\n\n            if reward_info.env_assertions:\n\
      \                logger.info(f\"\\nEnvironment Assertions: {len(reward_info.env_assertions)}\
      \ checks\")\n                for i, check in enumerate(reward_info.env_assertions):\n\
      \                    logger.info(f\"  [{i+1}] {check.env_assertion}: met={check.met},\
      \ reward={check.reward}\")\n\n            if reward_info.action_checks:\n  \
      \              logger.info(f\"\\nAction Checks: {len(reward_info.action_checks)}\
      \ checks\")\n                for i, check in enumerate(reward_info.action_checks):\n\
      \                    logger.info(f\"  [{i+1}] {check.action}: match={check.action_match},\
      \ reward={check.action_reward}\")\n\n            if reward_info.nl_assertions:\n\
      \                logger.info(f\"\\nNL Assertions: {len(reward_info.nl_assertions)}\
      \ checks\")\n                for i, check in enumerate(reward_info.nl_assertions):\n\
      \                    logger.info(f\"  [{i+1}] {check.nl_assertion}: met={check.met}\"\
      )\n                    if check.justification:\n                        logger.info(f\"\
      \      Justification: {check.justification}\")\n\n            if reward_info.communicate_checks:\n\
      \                logger.info(f\"\\nCommunication Checks: {len(reward_info.communicate_checks)}\
      \ checks\")\n                for i, check in enumerate(reward_info.communicate_checks):\n\
      \                    logger.info(f\"  [{i+1}] {check.info}: met={check.met}\"\
      )\n                    if check.justification:\n                        logger.info(f\"\
      \      Justification: {check.justification}\")\n\n            if reward_info.info:\n\
      \                logger.info(f\"\\nAdditional Info: {reward_info.info}\")\n\n\
      \            logger.info(\"=\" * 60)\n\n        except Exception as e:\n   \
      \         logger.error(f\"Evaluation failed: {e}\")\n            import traceback\n\
      \            traceback.print_exc()\n            reward = 0.0\n\n        # =====\
      \ REWARD (second yield) =====\n        yield reward\n"
    arguments:
    - name: domain
      required: false
      default: airline
      type: string
    - name: task_id
      required: false
      default: 0
      inputSchema:
        anyOf:
        - type: integer
        - type: string
    - name: task_split
      required: false
      default: base
      type: string
    _fastmcp:
      tags: []
- uri: file:///setup/functions
  name: setup Functions Catalogue
  description: List of internal functions available in setup
  mime_type: application/json
  meta:
    _fastmcp:
      tags: []
- uri: file:///evaluate/functions
  name: evaluate Functions Catalogue
  description: List of internal functions available in evaluate
  mime_type: application/json
  meta:
    _fastmcp:
      tags: []
